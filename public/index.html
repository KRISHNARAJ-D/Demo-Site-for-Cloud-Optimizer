<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Render Cloud Demo</title>

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body>

<header class="topbar">
  <div class="brand">
    <h1>Render Cloud Demo</h1>
    <p class="sub">Simple cloud metrics, autoscaler simulation & CPU load tester</p>
  </div>

  <div class="actions">
    <label>Burn ms:
      <input id="burnMs" type="number" value="800" min="50" step="50" />
    </label>
    <button id="burnBtn" class="btn">Trigger Burn</button>
    <button id="burstBtn" class="btn alt">Burst (5x)</button>
    <a class="btn link" href="/status" target="_blank">Raw /status</a>
  </div>
</header>

<main class="container">
  <section class="left">
    <div class="card">
      <h2>Live Metrics</h2>
      <div class="metrics-grid">

        <div class="metric">
          <div class="label">Uptime</div>
          <div id="uptime" class="value">-</div>
        </div>

        <div class="metric">
          <div class="label">CPU cores</div>
          <div id="cpus" class="value">-</div>
        </div>

        <div class="metric">
          <div class="label">CPU Usage</div>
          <div id="cpu_val" class="value">- %</div>
        </div>

        <div class="metric">
          <div class="label">RSS Memory</div>
          <div id="rss" class="value">- MB</div>
        </div>

        <div class="metric">
          <div class="label">Heap Used</div>
          <div id="heap" class="value">- MB</div>
        </div>

      </div>
    </div>

    <div class="card">
      <h2>CPU / Memory History (Autoscaler Aware)</h2>
      <canvas id="chart" height="160"></canvas>
    </div>

    <div class="card autoscaler-card">
      <h2>Autoscaler Simulation</h2>

      <div class="auto-grid">
        <div>
          <strong>Scaler Decision:</strong>
          <div id="scale_state" class="state-label">-</div>
        </div>

        <div>
          <strong>Instances Running:</strong>
          <div id="instance_count" class="state-label">1</div>
        </div>
      </div>

      <p class="hint">
        Scaler checks CPU every 3 seconds.<br>
        Scale Up > 70% CPU<br>
        Scale Down < 30% CPU
      </p>

      <!-- INSTANCE DIAGRAM -->
      <div class="instances-wrapper">
        <h3 class="instances-title">Simulated Cloud Instances</h3>
        <div id="instances" class="instances-grid" aria-live="polite"></div>
      </div>
    </div>

  </section>

  <aside class="right">
    <div class="card small">
      <h3>Recent Events</h3>
      <ul id="events" class="events"></ul>
    </div>
  </aside>
</main>

<footer class="footer">
  <small>Live metrics update every 2 seconds. Autoscaler acts every 3 seconds.</small>
</footer>

<script>
(() => {
  const statusUrl = "/status";

  const maxPoints = 40;
  const labels = [];
  const cpuData = [];
  const rssData = [];
  const heapData = [];

  let instances = 1; // simulated cloud instances
  const maxInstances = 6;
  const minInstances = 1;

  // Chart setup
  const chart = new Chart(document.getElementById("chart"), {
    type: "line",
    data: {
      labels,
      datasets: [
        { label: "CPU %", borderColor: "#ef4444", borderWidth: 2, data: cpuData, tension: 0.3 },
        { label: "RSS (MB)", borderColor: "#60a5fa", borderWidth: 2, data: rssData, tension: 0.3 },
        { label: "Heap (MB)", borderColor: "#f472b6", borderWidth: 2, data: heapData, tension: 0.3 }
      ]
    },
    options: {
      animation: false,
      responsive: true,
      scales: {
        y: { beginAtZero: true }
      }
    }
  });

  const eventsEl = document.getElementById("events");
  const instancesEl = document.getElementById("instances");

  function addEvent(msg) {
    const li = document.createElement("li");
    li.innerText = new Date().toLocaleTimeString() + " â€” " + msg;
    eventsEl.prepend(li);
    while (eventsEl.children.length > 15) eventsEl.removeChild(eventsEl.lastChild);
  }

  function renderInstances(count) {
    // Smooth update: compare with current DOM count and animate additions/removals
    const current = instancesEl.children.length;
    if (count === current) return;

    // If increasing: add with entry animation
    if (count > current) {
      for (let i = current + 1; i <= count; i++) {
        const box = document.createElement("div");
        box.className = "instance-box entry";
        box.setAttribute("data-instance", i);
        box.innerHTML = `<div class="inst-header">Instance ${i}</div><div class="inst-sub">running</div>`;
        instancesEl.appendChild(box);
        // trigger reflow then remove 'entry' class for CSS animation to play
        requestAnimationFrame(() => box.classList.remove("entry"));
      }
    } else {
      // If decreasing: remove with exit animation
      for (let i = current; i > count; i--) {
        const node = instancesEl.querySelector('[data-instance="' + i + '"]');
        if (!node) continue;
        node.classList.add("exit");
        // after animation remove
        node.addEventListener("animationend", () => {
          if (node && node.parentNode) node.parentNode.removeChild(node);
        }, { once: true });
      }
    }
  }

  async function fetchStatus() {
    try {
      const r = await fetch(statusUrl);
      const s = await r.json();

      document.getElementById("uptime").innerText = s.uptime_s + "s";
      document.getElementById("cpus").innerText = s.cpus;

      const cpuBox = document.getElementById("cpu_val");
      cpuBox.innerText = s.cpu_percent + " %";

      if (s.cpu_percent < 30) cpuBox.style.color = "#4ade80";
      else if (s.cpu_percent < 70) cpuBox.style.color = "#facc15";
      else cpuBox.style.color = "#ef4444";

      document.getElementById("rss").innerText = s.memory_rss_mb + " MB";
      document.getElementById("heap").innerText = s.memory_heap_used_mb + " MB";

      labels.push(new Date(s.timestamp).toLocaleTimeString());
      cpuData.push(s.cpu_percent);
      rssData.push(s.memory_rss_mb);
      heapData.push(s.memory_heap_used_mb);

      if (labels.length > maxPoints) {
        labels.shift(); cpuData.shift(); rssData.shift(); heapData.shift();
      }

      chart.update();
      return s.cpu_percent;
    } catch (err) {
      addEvent("Error fetching /status: " + (err.message || err));
      return null;
    }
  }

  // Autoscaler interval
  setInterval(async () => {
    const cpu = await fetchStatus();
    if (cpu === null) return;

    const scaleLabel = document.getElementById("scale_state");
    const instanceLabel = document.getElementById("instance_count");

    if (cpu > 70 && instances < maxInstances) {
      instances++;
      scaleLabel.innerText = "Scale Up";
      scaleLabel.style.color = "#ef4444";
      addEvent("ðŸš€ Scaled Up â†’ Instances: " + instances);
      renderInstances(instances);
    }
    else if (cpu < 30 && instances > minInstances) {
      instances--;
      scaleLabel.innerText = "Scale Down";
      scaleLabel.style.color = "#4ade80";
      addEvent("ðŸ“‰ Scaled Down â†’ Instances: " + instances);
      renderInstances(instances);
    }
    else {
      scaleLabel.innerText = "Stable";
      scaleLabel.style.color = "#facc15";
    }

    instanceLabel.innerText = instances;
  }, 3000);

  // initial render of one instance
  renderInstances(instances);

  // initial fetch so chart isn't empty
  fetchStatus();

  // BURN ACTIONS
  document.getElementById("burnBtn").onclick = async () => {
    const ms = Number(document.getElementById("burnMs").value);
    addEvent("Burn triggered: " + ms + "ms");
    await fetch("/burn?ms=" + ms);
  };

  document.getElementById("burstBtn").onclick = () => {
    const ms = Number(document.getElementById("burnMs").value);
    addEvent("Burst x5 (" + ms + "ms)");
    for (let i = 0; i < 5; i++) fetch("/burn?ms=" + ms);
  };

})();
</script>

</body>
</html>
